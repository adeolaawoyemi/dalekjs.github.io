<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - dalek-internal-assertions</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="dalek-internal-assertions"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Dalek.Internal.Assertions.html">Dalek.Internal.Assertions</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Assertions.html">Assertions</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: index.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 *
 * Copyright (c) 2013 Sebastian Golasch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

&#x27;use strict&#x27;;

// ext. libs
var Q = require(&#x27;q&#x27;);
var uuid = require(&#x27;node-uuid&#x27;);
var chai = require(&#x27;chai&#x27;);

// Module variable
var Assertions;

/**
 * @module Assertions
 * @class Assertions
 * @namespace Dalek.Internal
 */

module.exports = function () {
  return Assertions;
};

/**
 * @constructor
 * @part Assertions
 * @api
 */

Assertions = function (opts) {
  this.test = opts.test;
  this.proceeded = [];
  this.chaining = false;
};

/**
 * Starts assertion chaining
 *
 * @method chain
 * @api
 */

Assertions.prototype.chain = function () {
  this.test.lastChain.push(&#x27;chaining&#x27;);
  this.chaining = true;
  return this;
};

/**
 * Ends an assertion chain
 *
 * @method end
 * @api
 */

Assertions.prototype.end = function () {
  var lastAction = this.test.lastChain.pop();
  if (lastAction === &#x27;chaining&#x27;) {
    this.chaining = false;
  }

  if (lastAction  === &#x27;querying&#x27;) {
    this.test.querying = false;
  }
  return this.test;
};

/**
 * Asserts that a given ressource does exist in the environment.
 *
 * @method resourceExists
 * @api
 */

Assertions.prototype.resourceExists = function (url, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;resourceExists&#x27;, &#x27;resourceExists&#x27;, this._testTruthy, hash, {url: url, message: message}).bind(this.test);
  this._addToActionQueue([url, hash], &#x27;resourceExists&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that a given element appears n times on the page.
 *
 *
 * Given this portion of html, you would like to assure that all of these elements
 * are ending up in your rendered markup on your page.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;section id=&quot;blog-overview&quot;&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 * &lt;/section&gt;
 * &#x60;&#x60;&#x60;
 *
 * The simple solution is to check if all these elements are present
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;, 4, &#x27;4 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 * The alternate syntax for this is:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is(4, &#x27;4 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you are not sure how many elements will exactly end up in your markup,
 * you could use the between assertion handler
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.between(2, 6, &#x27;Between 2 and 6 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you dealing with the situation that you have a minimum of elements,
 * you expect, you can use this helper...
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.gt(2, &#x27;At least 3 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 * ... if you want to know if its &#x27;greater than equal&#x27;, you can use this one...
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.gte(2, &#x27;At least 2 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 * ... as well as their &#x27;lower than&#x27; and &#x27;lower than equal&#x27; equivalents
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.lt(5, &#x27;Less than 5 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.lte(5, &#x27;Less than, or 5 blog teasers are present&#x27;)
 * &#x60;&#x60;&#x60;
 * And if you just wan&#x27;t to know, if a certain amount of teasers isn&#x27;t present,
 * you can still use the &#x27;:not(): assertion helper
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.not(5, &#x27;There are more or less than 5 teasers present&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you wan&#x27;t to allow multiple correct values, you can use the &#x27;:are()&#x27; helper
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .are([1,3,6], &#x27;Teaser count is an odd number between 1 and 6&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * of couse you can test for the opoosite with &#x27;:are()&#x27;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfElements(&#x27;#blog-overview .teaser&#x27;)
 *     .are([0,2,4], &#x27;Teaser count is not an even number between 1 and 6&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method numberOfElements
 */

Assertions.prototype.numberOfElements = function (selector, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;numberOfElements&#x27;, &#x27;numberOfElements&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;getNumberOfElements&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 *
 * Asserts that a given element is visible n times in the current viewport.
 *
 *
 * Given this portion of html, you would like to assure that all of these elements
 * are ending up in your rendered markup on your page.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;section id=&quot;blog-overview&quot;&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 *   &lt;article class=&quot;teaser&quot;&gt;&lt;/article&gt;
 * &lt;/section&gt;
 * &#x60;&#x60;&#x60;
 *
 * The simple solution is to check if all these elements are visible
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;, 4, &#x27;4 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 * The alternate syntax for this is:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is(4, &#x27;4 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you are not sure how many elements will exactly be shown in the current viewport,
 * you could use the between assertion handler
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.between(2, 6, &#x27;Between 2 and 6 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you dealing with the situation that you have a minimum of elements,
 * you expect, you can use this helper...
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.gt(2, &#x27;At least 3 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 * ... if you want to know if its &#x27;greater than equal&#x27;, you can use this one...
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.gte(2, &#x27;At least 2 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 * ... as well as their &#x27;lower than&#x27; and &#x27;lower than equal&#x27; equivalents
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.lt(5, &#x27;Less than 5 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.lte(5, &#x27;Less than, or 5 blog teasers are visible&#x27;)
 * &#x60;&#x60;&#x60;
 * And if you just wan&#x27;t to know, if a certain amount of teasers isn&#x27;t visible,
 * you can still use the &#x27;:not(): assertion helper
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .is.not(5, &#x27;There are more or less than 5 teasers visible&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * If you wan&#x27;t to allow multiple correct values, you can use the &#x27;:are()&#x27; helper
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .are([1,3,6], &#x27;Teaser count is an odd number between 1 and 6&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * of couse you can test for the opoosite with &#x27;:are()&#x27; and &#x27;:not()&#x27;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.numberOfVisibleElements(&#x27;#blog-overview .teaser&#x27;)
 *     .are.not([0,2,4], &#x27;Teaser count is not an even number between 1 and 6&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method numberOfVisibleElements
 */

Assertions.prototype.numberOfVisibleElements = function (selector, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;numberOfVisibleElements&#x27;, &#x27;numberOfVisibleElements&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;getNumberOfVisibleElements&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that a given form field has the provided value.
 *
 * Given this portion of html, we would like to get the information which option element
 * is currently selected.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;form name=&quot;fav-doctor&quot; id=&quot;fav-doctor&quot;&gt;
 *   &lt;select id=&quot;the-doctors&quot;&gt;
 *     &lt;option value=&quot;9&quot;&gt;Eccleston&lt;/option&gt;
 *     &lt;option selected value=&quot;10&quot;&gt;Tennant&lt;/option&gt;
 *     &lt;option value=&quot;11&quot;&gt;Smith&lt;/option&gt;
 *   &lt;/select&gt;
 * &lt;/form&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test
 *   .val(&#x27;#the-doctors&#x27;, 10, &#x27;David is the favourite&#x27;)
 *   // lets change the favourite by selection the last option
 *  .click(&#x27;#the-doctors option:last&#x27;)
 *  .val(&#x27;#the-doctors&#x27;, 11, &#x27;Matt is now my favourite, bow ties are cool&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * This assertion is capable of getting the values from every form element
 * that holds a value attribute
 *
 * Getting texts out of normal input fields is pretty straight forward
 *
 * &#x60;&#x60;&#x60;html
 * &lt;label for=&quot;fav-enemy&quot;&gt;Tell my your favourity Who enemy:&lt;/label&gt;
 * &lt;input id=&quot;fav-enemy&quot; name=&quot;fav-enemy&quot; type=&quot;text&quot; value=&quot;Daleks&quot; /&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test
 *   .val(&#x27;#fav-enemy&#x27;, &#x27;Daleks&#x27;, &#x27;Daleks are so cute&#x27;)
 *   // lets change the favourite by typing smth. new
 *  .type(&#x27;#fav-enemy&#x27;, &#x27;Cyberman&#x27;)
 *  .val(&#x27;#fav-enemy&#x27;, &#x27;Cyberman&#x27;, &#x27;Cyberman are so cyber&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * Of course, you can use a bunch of assertion helpers, to enable
 * yourself to do more than just one assertion with the &#x27;:are()&#x27; helper.
 *
 * &#x60;&#x60;&#x60;javascript
 * test
 *   .val(&#x27;#fav-enemy&#x27;)
 *   .is(&#x27;Daleks&#x27;, &#x27;Still cute, those daleks&#x27;)
 *   .is.not(&#x27;Klingons&#x27;, &#x27;Different fandom bro&#x27;)
 *   // yep, multiple mentions are allowed
 *   .are([&#x27;Daleks&#x27;, &#x27;Cyberman&#x27;, &#x27;The master&#x27;], &#x27;All of them are cool&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @method val
 * @api
 */


Assertions.prototype.val = function (selector, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;val&#x27;, &#x27;val&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;val&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.css = function (selector, property, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = property;
    property = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;css&#x27;, &#x27;css&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, porperty: property, message: message}).bind(this.test);
  this._addToActionQueue([selector, property, expected, hash], &#x27;css&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.width = function (selector, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;width&#x27;, &#x27;width&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;width&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.height = function (selector, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;height&#x27;, &#x27;height&#x27;, this._testShallowEquals, hash, {expected: expected, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;height&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.selected = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;selected&#x27;, &#x27;selected&#x27;, this._testShallowEquals, hash, {expected: true, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, true, hash], &#x27;selected&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.notSelected = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;selected&#x27;, &#x27;selected&#x27;, this._testShallowEquals, hash, {expected: false, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, false, hash], &#x27;selected&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.enabled = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;enabled&#x27;, &#x27;enabled&#x27;, this._testShallowEquals, hash, {expected: true, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, true, hash], &#x27;enabled&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.disabled = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;enabled&#x27;, &#x27;enabled&#x27;, this._testShallowEquals, hash, {expected: false, selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, false, hash], &#x27;enabled&#x27;, cb);
  return this.chaining ? this : this.test;
};

Assertions.prototype.cookie = function (name, expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;cookie&#x27;, &#x27;cookie&#x27;, this._testShallowEquals, hash, {expected: expected, name: name, message: message}).bind(this.test);
  this._addToActionQueue([name, expected, hash], &#x27;cookie&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that current HTTP status code is the same as the one passed as argument.
 * TODO: Needs some work
 */

Assertions.prototype.httpStatus = function (status, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;httpStatus&#x27;, &#x27;httpStatus&#x27;, this._testShallowEquals, hash, {expected: status, message: message}).bind(this.test);
  this._addToActionQueue([status, hash], &#x27;httpStatus&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that an element matching the provided selector expression exists in remote DOM environment.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;body&gt;
 *   &lt;p id=&quot;so-lonely&quot;&gt;Last of the timelords&lt;/p&gt;
 * &lt;/body&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test
 *   .exists(&#x27;#so-lonely&#x27;, &#x27;The loneliest element in the universe exists&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * @method exists
 * @api
 */

Assertions.prototype.exists = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;exists&#x27;, &#x27;exists&#x27;, this._testTruthy, hash, {selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, hash], &#x27;exists&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that an element matching the provided selector expression doesn&#x27;t exists within the remote DOM environment.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;body&gt;
 *   &lt;p id=&quot;so-lonely&quot;&gt;Last of the timelords&lt;/p&gt;
 * &lt;/body&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test
 *   .doesntExist(&#x27;#the-master&#x27;, &#x27;The master element has not been seen&#x27;)
 * &#x60;&#x60;&#x60;
 *
 * @method doesntExist
 * @api
 */

Assertions.prototype.doesntExist = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;exists&#x27;, &#x27;!exists&#x27;, this._testFalsy, hash, {selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, hash], &#x27;exists&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that the element matching the provided selector expression is not visible.
 */

Assertions.prototype.notVisible = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;visible&#x27;, &#x27;!visible&#x27;, this._testFalsy, hash, {selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, hash], &#x27;visible&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that the element matching the provided selector expression is visible.
 */

Assertions.prototype.visible = function (selector, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;visible&#x27;, &#x27;visible&#x27;, this._testTruthy, hash, {selector: selector, message: message}).bind(this.test);
  this._addToActionQueue([selector, hash], &#x27;visible&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that given text does not exist in the provided selector.
 */

Assertions.prototype.doesntHaveText = function (selector, expected, message) {
  var hash = uuid.v4();
  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;text&#x27;, &#x27;!text&#x27;, this._testShallowUnequals, hash, {selector: selector, expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;text&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that given text does not exist in the provided selector.
 */

Assertions.prototype.alertDoesntHaveText = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;alertText&#x27;, &#x27;!alertText&#x27;, this._testShallowUnequals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;alertText&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that given text does exist in the provided selector.
 */

Assertions.prototype.text = function (selector, expected, message) {
  var hash = uuid.v4();
  if (this.test.querying === true) {
    message = expected;
    expected = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;text&#x27;, &#x27;text&#x27;, this._testShallowEquals, hash, {selector: selector, expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([selector, expected, hash], &#x27;text&#x27;, cb);
  return (this.chaining || this.test.querying) ? this : this.test;
};

/**
 * Asserts that given alertText does exist in the provided alert/confirm or prompt dialog.
 */

Assertions.prototype.alertText = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;alertText&#x27;, &#x27;alertText&#x27;, this._testShallowEquals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;alertText&#x27;, cb);
  return (this.chaining || this.test.querying) ? this : this.test;
};

/**
 * Asserts that given text does exist in the provided selector.
 *
 * @param {String} expected
 * @param {String} message
 * @return {Object}
 */

Assertions.prototype.title = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;title&#x27;, &#x27;title&#x27;, this._testShallowEquals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;title&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 * Asserts that given title does not mathc the given expactions
 *
 * @param {String} expected
 * @param {String} message
 * @return {Object}
 */

Assertions.prototype.doesntHaveTitle = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;title&#x27;, &#x27;!title&#x27;, this._testShallowUnequals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;title&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 *
 */

Assertions.prototype.url = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;url&#x27;, &#x27;url&#x27;, this._testShallowEquals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;url&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 *
 */

Assertions.prototype.doesntHaveUrl = function (expected, message) {
  var hash = uuid.v4();
  var cb = this._generateCallbackAssertion(&#x27;url&#x27;, &#x27;!url&#x27;, this._testShallowUnequals, hash, {expected: expected, message: message}).bind(this.test);
  this._addToActionQueue([expected, hash], &#x27;url&#x27;, cb);
  return this.chaining ? this : this.test;
};

/**
 *
 */

Assertions.prototype.attr = function (selector, attribute, expected, message) {
  var hash = uuid.v4();

  if (this.test.querying === true) {
    message = expected;
    expected = attribute;
    attribute = selector;
    selector = this.test.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;attribute&#x27;, &#x27;attribute&#x27;, this._testShallowEquals, hash, {expected: expected, message: message, selector: selector, attribute: attribute}).bind(this.test);
  this._addToActionQueue([selector, attribute, expected, hash], &#x27;attribute&#x27;, cb);
  return this.chaining ? this : this.test;
};

// TEST HELPER
// -----------

/**
 *
 */

Assertions.prototype.is = function (expected, message) {
  return this.generateTestHelper(&#x27;is&#x27;, &#x27;_testShallowEquals&#x27;, false)(expected, message);
};


/**
 *
 */

Assertions.prototype.not = function (expected, message) {
  return this.generateTestHelper(&#x27;not&#x27;, &#x27;_testShallowEquals&#x27;, true)(expected, message);
};

/**
 *
 */

Assertions.prototype.between = function (expected, message) {
  return this.generateTestHelper(&#x27;between&#x27;, &#x27;_testBetween&#x27;, false)(expected, message);
};

/**
 *
 */

Assertions.prototype.gt = function (expected, message) {
  return this.generateTestHelper(&#x27;gt&#x27;, &#x27;_testGreaterThan&#x27;, false)(expected, message);
};

/**
 *
 */

Assertions.prototype.gte = function (expected, message) {
  return this.generateTestHelper(&#x27;gte&#x27;, &#x27;_testGreaterThanEqual&#x27;, false)(expected, message);
};

/**
 *
 */

Assertions.prototype.lt = function (expected, message) {
  return this.generateTestHelper(&#x27;lt&#x27;, &#x27;_testLowerThan&#x27;, false)(expected, message);
};

/**
 *
 */

Assertions.prototype.lte = function (expected, message) {
  return this.generateTestHelper(&#x27;lte&#x27;, &#x27;_testLowerThanEqual&#x27;, false)(expected, message);
};

// HELPER METHODS
// --------------

/**
 *
 */

Assertions.prototype._generateCallbackAssertion = function (key, type, test, hash, opts) {
  var cb = function (data) {
    if (data &amp;&amp; data.key === key &amp;&amp; data.hash === hash) {

      this._lastGeneratedAction = {key: key, type: type, test: test, hash: hash, opts: opts, data: data};

      if (!opts.expected &amp;&amp; (key === &#x27;title&#x27; || key === &#x27;width&#x27; || key === &#x27;height&#x27; || key === &#x27;url&#x27; || key === &#x27;text&#x27; || key === &#x27;attribute&#x27; || key === &#x27;numberOfElements&#x27; || key === &#x27;numberOfVisibleElements&#x27;)) {
        return false;
      }

      var testResult = test(data.value, opts.expected);

      this.reporter.emit(&#x27;report:assertion&#x27;, {
        success: testResult,
        expected: opts.expected,
        value: data.value,
        message: opts.message,
        type: type
      });

      this.incrementExpectations();
      if (!testResult) {
        this.incrementFailedAssertions();
      }
    }
  };
  return cb;
};

/**
 *
 */

Assertions.prototype._addToActionQueue = function (opts, driverMethod, cb) {
  this._lastGeneratedShit = {opts: opts, driverMethod: driverMethod};
  this.test.actionPromiseQueue.push(function () {
    var deferredAction = Q.defer();
    this.test.driver[driverMethod].apply(this.test.driver, opts);
    deferredAction.resolve();
    this.test.driver.events.on(&#x27;driver:message&#x27;, cb);
    return deferredAction.promise;
  }.bind(this));
  return this;
};

/**
 *
 */

Assertions.prototype.generateTestHelper = function (name, assertionFn, negate) {
  return function (expected, message) {
    var gen = this._lastGeneratedShit;

    this.test.actionPromiseQueue.push(function () {
      var deferredAction = Q.defer();
      deferredAction.resolve();
      this.test.driver.events.on(&#x27;driver:message&#x27;, function () {

        if (gen.opts &amp;&amp; gen.opts[(gen.opts.length - 1)] &amp;&amp; this.test._lastGeneratedAction &amp;&amp; this.test._lastGeneratedAction.hash) {
          if (gen.opts[(gen.opts.length - 1)] === this.test._lastGeneratedAction.hash &amp;&amp; !this.proceeded[this.test._lastGeneratedAction.hash + name]) {
            var testResult = this[assertionFn](expected, this.test._lastGeneratedAction.data.value);

            if (negate) {
              testResult = !testResult;
            }

            this.proceeded[this.test._lastGeneratedAction.hash + name] = true;

            this.test.reporter.emit(&#x27;report:assertion&#x27;, {
              success: testResult,
              expected: expected,
              value: this.test._lastGeneratedAction.data.value,
              message: message,
              type: this.test._lastGeneratedAction.type
            });

            this.test.incrementExpectations();

            if (!testResult) {
              this.test.incrementFailedAssertions();
            }
          }
        }
      }.bind(this));
      return deferredAction.promise;
    }.bind(this));

    return this.chaining ? this : this.test;
  }.bind(this);
};

// ASSERT METHODS
// --------------

/**
 * Assert if a given value shallow equals a snd. given value
 *
 * @method _testShallowEquals
 * @param {mixed} a Value to test
 * @param {mixed} b Value to test
 * @return {bool} false if values don&#x27;t match, true if they match
 * @private
 */

Assertions.prototype._testShallowEquals = function (a, b) {
  try {
    chai.assert.equal(a, b);
  } catch (e) {
    return false;
  }

  return true;
};

/**
 * Assert if a given value shallow does not equal a snd. given value
 *
 * @method _testShallowUnequals
 * @param {mixed} a Value to test
 * @param {mixed} b Value to test
 * @return {bool} true if values don&#x27;t match, false if they match
 * @private
 */

Assertions.prototype._testShallowUnequals = function (a, b) {
  try {
    chai.assert.notEqual(a, b);
  } catch (e) {
    return false;
  }

  return true;
};


Assertions.prototype._testBetween = function (a, b) {
  try {
    chai.expect(b).to.be.within(a[0], a[1]);
  } catch (e) {
    return false;
  }

  return true;
};

Assertions.prototype._testGreaterThan = function (a, b) {
  try {
    chai.expect(b).to.be.above(a);
  } catch (e) {
    return false;
  }

  return true;
};

Assertions.prototype._testGreaterThanEqual = function (a, b) {
  return this._testGreaterThan(a - 1, b);
};

Assertions.prototype._testLowerThan = function (a, b) {
  try {
    chai.expect(b).to.be.below(a);
  } catch (e) {
    return false;
  }

  return true;
};

Assertions.prototype._testLowerThanEqual = function (a, b) {
  return this._testLowerThan(a + 1, b);
};

/**
 * Assert if a given value is boolean &#x27;true&#x27;
 *
 * @method _testTruthy
 * @param {bool} a Value to test
 * @return {bool} false if value is false, true if value is true
 * @private
 */

Assertions.prototype._testTruthy = function (a) {
  return a === &#x27;true&#x27; || a === true;
};

/**
 * Assert if a given value is boolean &#x27;false&#x27;
 *
 * @method _testFalsy
 * @param {bool} a Value to test
 * @return {bool} true if value is false, false if value is true
 * @private
 */

Assertions.prototype._testFalsy = function (a) {
  return a === &#x27;false&#x27; || a === false;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
